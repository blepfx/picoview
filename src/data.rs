use crate::GlContext;
use bitflags::bitflags;
use std::{fmt::Debug, path::PathBuf};

/// A mouse cursor icon that is predefined by the platform.
///
/// Not all platforms support all cursor types, in which case a closest matching cursor is used.
#[derive(Clone, Copy, Default, Debug, Eq, PartialEq, Hash)]
#[repr(u8)]
#[allow(missing_docs)]
#[non_exhaustive]
pub enum MouseCursor {
    #[default]
    Default,
    Hidden,

    Hand,
    HandGrabbing,
    Help,

    Text,
    VerticalText,

    Working,
    PtrWorking,

    NotAllowed,
    PtrNotAllowed,

    ZoomIn,
    ZoomOut,

    Alias,
    Copy,
    Move,
    AllScroll,
    Cell,
    Crosshair,

    EResize,
    NResize,
    NeResize,
    NwResize,
    SResize,
    SeResize,
    SwResize,
    WResize,
    EwResize,
    NsResize,
    NwseResize,
    NeswResize,
    ColResize,
    RowResize,
}

bitflags! {
    /// Key modifier flags that are tracked separately from key events
    #[derive(Clone, Copy, Eq, PartialEq, Debug)]
    pub struct Modifiers: u16 {
        /// Alt key (right or left)
        const ALT = 1 << 0;

        /// Control key (right or left)
        const CTRL = 1 << 1;

        /// Meta key (or Windows key)
        const META = 1 << 2;

        /// Shift key (right or left)
        const SHIFT = 1 << 3;

        /// Scroll lock active
        const SCROLL_LOCK = 1 << 4;

        /// Num lock active
        const NUM_LOCK = 1 << 5;

        /// Caps lock active
        const CAPS_LOCK = 1 << 6;
    }
}

/// A fractional point in physical pixels with top-left origin
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct Point {
    /// The x coordinate
    pub x: f32,

    /// The y coordinate
    pub y: f32,
}

/// Integer size in physical pixels
#[derive(Copy, Clone, Debug, PartialEq, Default)]
pub struct Size {
    /// The width in physical pixels
    pub width: u32,

    /// The height in physical pixels
    pub height: u32,
}

impl From<(u32, u32)> for Size {
    fn from((width, height): (u32, u32)) -> Self {
        Self { width, height }
    }
}

impl From<(u32, u32)> for Point {
    fn from((x, y): (u32, u32)) -> Self {
        Self {
            x: x as f32,
            y: y as f32,
        }
    }
}

impl From<(f32, f32)> for Point {
    fn from((x, y): (f32, f32)) -> Self {
        Self { x, y }
    }
}

/// A mouse button.
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub enum MouseButton {
    /// Left mouse button
    Left,
    /// Right mouse button
    Right,
    /// Middle mouse button (usually the scroll wheel button)
    Middle,
    /// Forward mouse button (usually the 4th button)
    Forward,
    /// Back mouse button (usually the 5th button)
    Back,
}

/// A logical key of a keyboard.
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[allow(missing_docs)]
#[non_exhaustive]
pub enum Key {
    Backquote,
    Backslash,
    BracketLeft,
    BracketRight,
    Comma,
    D0,
    D1,
    D2,
    D3,
    D4,
    D5,
    D6,
    D7,
    D8,
    D9,
    A,
    B,
    C,
    D,
    E,
    F,
    G,
    H,
    I,
    J,
    K,
    L,
    M,
    N,
    O,
    P,
    Q,
    R,
    S,
    T,
    U,
    V,
    W,
    X,
    Y,
    Z,
    Equal,
    Minus,
    Period,
    Quote,
    Semicolon,
    Slash,
    AltLeft,
    AltRight,
    Backspace,
    CapsLock,
    ContextMenu,
    ControlLeft,
    ControlRight,
    Enter,
    MetaLeft,
    MetaRight,
    ShiftLeft,
    ShiftRight,
    Space,
    Tab,
    Delete,
    End,
    Home,
    Insert,
    PageDown,
    PageUp,
    ArrowDown,
    ArrowLeft,
    ArrowRight,
    ArrowUp,
    NumLock,
    Numpad0,
    Numpad1,
    Numpad2,
    Numpad3,
    Numpad4,
    Numpad5,
    Numpad6,
    Numpad7,
    Numpad8,
    Numpad9,
    NumpadAdd,
    NumpadBackspace,
    NumpadClear,
    NumpadClearEntry,
    NumpadComma,
    NumpadDecimal,
    NumpadDivide,
    NumpadEnter,
    NumpadEqual,
    NumpadHash,
    NumpadMemoryAdd,
    NumpadMemoryClear,
    NumpadMemoryRecall,
    NumpadMemoryStore,
    NumpadMemorySubtract,
    NumpadMultiply,
    NumpadParenLeft,
    NumpadParenRight,
    NumpadStar,
    NumpadSubtract,
    Escape,
    Fn,
    FnLock,
    PrintScreen,
    ScrollLock,
    F1,
    F2,
    F3,
    F4,
    F5,
    F6,
    F7,
    F8,
    F9,
    F10,
    F11,
    F12,
}

/// An event generated by the windowing system and delivered to the event handler.
///
/// The core type of `picoview`.
#[derive(Debug)]
#[non_exhaustive]
pub enum Event<'a> {
    /// A wakeup event triggered by a call to [`WindowWaker::wakeup`](`crate::WindowWaker::wakeup`)
    Wakeup,

    /// User requested to close the window (by clicking the close button, or pressing Alt+F4, etc)
    ///
    /// To actually close the window, you have to call [`Window::close`](`crate::Window::close`).
    WindowClose,

    /// The window gained or lost focus.
    WindowFocus {
        /// `true` if the window gained focus, `false` if it lost focus
        focus: bool,
    },

    /// The window scale factor changed (for example, when moved to a different monitor).
    ///
    /// This is a hint that the application may want to adjust its rendering scale.
    ///
    /// Does not affect the coordinate system of positions and sizes, which are always in physical pixels.
    WindowScale {
        /// The new scale factor
        scale: f32,
    },

    /// The window was moved.
    WindowMove {
        /// The new position of the window.
        ///
        /// See [`Window::set_position`](`crate::Window::set_position`) for details on coordinate system.
        origin: Point,
    },

    /// The window was resized.
    WindowResize {
        /// The new size of the window.
        size: Size,
    },

    /// Frame event. You should redraw the window in response to this event.
    ///
    /// This event is sent at the refresh rate of the display (typically 60 Hz),
    /// on a best-effort basis (might use an unsynchronized timer depending on the platform).
    WindowFrame {
        /// An associated OpenGL context, if configured and present.
        gl: Option<&'a dyn GlContext>,
    },

    /// The area of the window that needs to be redrawn.
    ///
    /// This event may be sent multiple times before the next `WindowFrame` event.
    ///
    /// This is a hint, you can safely ignore it and redraw the whole window if you want.
    WindowDamage {
        /// The `x` coordinate of the top-left corner of the damaged area.
        x: u32,
        /// The `y` coordinate of the top-left corner of the damaged area.
        y: u32,
        /// The width of the damaged area.
        w: u32,
        /// The height of the damaged area.
        h: u32,
    },

    /// The mouse cursor left the window.
    ///
    /// Note that there is no corresponding event for when the mouse enters the window,
    /// you can track that yourself by checking for [`Event::MouseMove`] events.
    MouseLeave,

    /// The mouse cursor moved within the window.
    MouseMove {
        /// The position of the cursor relative to the window's client area.
        relative: Point,

        /// The position of the cursor relative to the entire screen.
        absolute: Point,
    },

    /// A mouse button was pressed.
    MouseDown {
        /// Which mouse button was pressed
        button: MouseButton,
    },

    /// A mouse button was released.
    MouseUp {
        /// Which mouse button was released
        button: MouseButton,
    },

    /// The mouse wheel was scrolled (can also represent touchpad scrolling).
    ///
    /// `picoview` normalizes scroll events to a consistent unit across platforms.
    MouseScroll {
        /// The amount scrolled in the horizontal direction
        x: f32,

        /// The amount scrolled in the vertical direction
        y: f32,
    },

    /// The state of the modifier keys (Shift, Ctrl, Alt, etc.) changed.
    KeyModifiers {
        /// The new state of the modifier keys
        modifiers: Modifiers,
    },

    /// A key was pressed.
    KeyDown {
        /// Which key was pressed
        key: Key,

        /// Set to `true` to indicate that the event has been handled and should not be propagated to the parent
        capture: &'a mut bool,
    },

    /// A key was released.
    KeyUp {
        /// Which key was released
        key: Key,

        /// Set to `true` to indicate that the event has been handled and should not be propagated to the parent
        capture: &'a mut bool,
    },

    /// TODO: not implemented yet
    #[allow(missing_docs)]
    DragHover { files: &'a [PathBuf] },

    /// TODO: not implemented yet
    #[allow(missing_docs)]
    DragAccept { files: &'a [PathBuf] },

    /// TODO: not implemented yet
    #[allow(missing_docs)]
    DragCancel,
}

/// An error that can occur during the creation or lifetime of a window.
#[derive(Debug)]
pub enum Error {
    /// A platform-specific error occurred.
    PlatformError(String),

    /// Failed to create an OpenGL context
    OpenGlError(String),

    /// The parent window passed was invalid.
    InvalidParent,
}

/// An error that can occur when waking up a event loop from another thread.
#[derive(Debug)]
pub enum WakeupError {
    /// The window has already been closed.
    Disconnected,
}
